# CSRF攻击与防御

## CSRF概念
`CSRF`跨站点请求伪造(`Cross—Site Request Forgery`)，跟`XSS`攻击一样，存在巨大的危害性，你可以这样来理解：
       
攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 

简单说，就是如果用户在攻击网站中保存了登陆状态，那么攻击者就可以利用这个登陆状态(`cookie`)，绕过后台的用户验证，冒充用户向服务器执行一些操作。

> 其本质就是利用`cookie`会在同源请求中携带发送给服务器的特点，以此实现用户的冒充。
 
## CSRF攻击介绍及防御

`CSRF`攻击攻击原理及过程如下，其中`Web A`为存在`CSRF`漏洞的网站，`Web B`为攻击者构建的恶意网站，`User C`为`Web A`网站的合法用户。

1. `用户C`打开浏览器，访问受信任`网站A`，输入用户名和密码请求登录；

2. 在用户信息通过验证后，`网站A`产生`Cookie`信息并返回给浏览器，此时用户登录`网站A`成功，可以正常发送请求到`网站A`；

3. 用户未退出`网站A`之前，在同一浏览器中，打开一个`TAB页`访问`网站B`；

4. `网站B`接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问`第三方站点A`；

5. 浏览器在接收到这些攻击性代码后，根据`网站B`的请求，在用户不知情的情况下携带`Cookie`信息，向`网站A`发出请求。`网站A`并不知道该请求其实是由`B`发起的，所以会根据`用户C`的`Cookie`信息以`C`的权限处理该请求，导致来自`网站B`的恶意代码被执行。 

## CSRF攻击实例

受害者`Bob`在银行有一笔存款，通过对银行的网站发送请求 `http://bank.example/withdraw?account=bob&amount=1000000&for=bob2` 可以使 `Bob`把 1000000 的存款转到 `bob2` 的账号下。

通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的`session`，并且该 `session`的用户 `Bob` 已经成功登陆。

黑客`Mallory`自己在该银行也有账户，他知道上文中的`URL` 可以把钱进行转帐操作。`Mallory` 可以自己发送一个请求给银行：`http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory`。但是这个请求来自 `Mallory` 而非 `Bob`，他不能通过安全认证，因此该请求不会起作用。

这时，`Mallory`想到使用`CSRF`的攻击方式，他先自己做一个网站，在网站中放入如下代码： `src=”http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory”`，并且通过广告等诱使 `Bob`来访问他的网站。

当`Bob`访问该网站时，上述 url 就会从 `Bob` 的浏览器发向银行，而这个请求会附带 `Bob` 浏览器中的 `cookie` 一起发向银行服务器。

大多数情况下，该请求会失败，因为他要求`Bob`的认证信息。

但是，如果`Bob`当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 `session` 尚未过期，浏览器的 `cookie` 之中含有 `Bob` 的认证信息。这时，悲剧发生了，这个 `url` 请求就会得到响应，钱将从 `Bob` 的账号转移到 `Mallory` 的账号，而 `Bob` 当时毫不知情。

等以后 `Bob` 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 `Mallory` 则可以拿到钱后逍遥法外。       

## CSRF漏洞检测
检测`CSRF`漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉`Referer`字段后再重新提交，如果该提交还有效，那么基本上可以确定存在`CSRF`漏洞。

随着对`CSRF`漏洞研究的不断深入，不断涌现出一些专门针对`CSRF`漏洞进行检测的工具，如`CSRFTester`，`CSRF Request Builder`等。

以`CSRFTester`工具为例，`CSRF`漏洞检测工具的测试原理如下：

使用`CSRFTester`进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在`CSRFTester`中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在`CSRF`漏洞，当然此款工具也可以被用来进行`CSRF`攻击。


## 防御CSRF攻击
目前防御 CSRF 攻击主要有三种策略：
1. 验证 `HTTP Referer` 字段
2. 自定义属性并验证
3. 设置`cookie`同源策略，限制不能被第三方使用

### 验证 HTTP Referer 字段

根据 `HTTP` 协议，在 `HTTP` 头中有一个字段叫 `Referer`，它记录了该 `HTTP` 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 `http://bank.example/withdraw?account=bob&amount=1000000&for=Mallory`，用户必须先登陆 `bank.example`，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 `Referer` 值就会是转账按钮所在的页面的 `URL`，通常是以 `bank.example `域名开头的地址。而如果黑客要对银行网站实施 `CSRF` 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 `Referer` 是指向黑客自己的网站。因此，要防御 `CSRF` 攻击，银行网站只需要对于每一个转账请求验证其 `Referer` 值，如果是以 `bank.example` 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 `Referer` 是其他网站的话，则有可能是黑客的 `CSRF` 攻击，拒绝该请求。

这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 `CSRF` 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 `Referer` 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。

然而，这种方法并非万无一失。`Referer` 的值是由浏览器提供的，虽然 `HTTP` 协议上有明确的要求，但是每个浏览器对于 `Referer` 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 `Referer` 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 `IE6` 或 `FF2`，目前已经有一些方法可以篡改 `Referer` 值。如果 `bank.example` 网站支持 `IE6` 浏览器，黑客完全可以把用户浏览器的 `Referer` 值设为以 `bank.example` 域名开头的地址，这样就可以通过验证，从而进行 `CSRF` 攻击。

即便是使用最新的浏览器，黑客无法篡改 `Referer` 值，这种方法仍然有问题。因为 `Referer` 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 `Referer` 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 `Referer`。当他们正常访问银行网站时，网站会因为请求没有 `Referer` 值而认为是 `CSRF` 攻击，拒绝合法用户的访问。

### 自定义属性并验证

 `CSRF` 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 `cookie` 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 `cookie` 来通过安全验证。

要抵御 `CSRF`，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 `cookie`之中。可以在 `HTTP` 请求中以参数的形式或者在`HTTP头部`加入一个随机产生的 `token`，并在服务器端建立一个拦截器来验证这个 `token`，如果请求中没有 `token` 或者 `token` 内容不正确，则认为可能是 `CSRF` 攻击而拒绝该请求。

这种方法要比检查 `Referer` 要安全一些，`token` 可以在用户登陆后产生并放于 `session` 之中，然后在每次请求时把 `token` 从 `session` 中拿出，与请求中的 `token` 进行比对。

随着分布式的出现，`session`的同步逐渐成为服务器一大麻烦，于是以时间换空间的`token`验证机制也应运而生，它不再存储于`session`之中，而是以特定的算法（一般是非对称加密）计算而出，又可以相应地解密出来，几乎可以认定是正确的。

::: tip axios防御CSRF攻击
现在最流行的`ajax`库`axios`，有一项能力就是可以防御`CSRF`攻击，本质就是这种方式。它有2个参数：
```
 xsrfCookieName: 'XSRF-TOKEN', // default
 xsrfHeaderName: 'X-XSRF-TOKEN', // default
```
前者是`cookie`中的`token`字段名称，也就是说，如果`cookie`中有这个字段，就会在接口请求的`headers`中添加一个`xsrfHeaderName`对应的字段，这个字段需要与后台约定好，后台拿到以后就可以进行校验了。
::: 

### 设置cookie同源策略

`Cookie`中的同源只关注域名，忽略协议和端口。所以`https://localhost:8080/`和`http://localhost:8081/`的`Cookie`是共享的。

什么是`SameSite`？

`SameSite`是`Cookie`中可放置并能够被浏览器识别的字段。`SameSite`可以有三个值，分别是`Strict`，`Lax`和`None`。

`Strict`表示该`Cookie`仅用作第一方`Cookie`。并且当用户从`A网站`移动到`B网站`时，首次访问中不发送标为`Strict`的`B`网站`Cookie`。这对安全性需求较高的网站比较适用。如果你的`B网站`登录状态为`登录中`，那么`A网站`点到`B网站`时，登录状态为`未登录`，用户需要再点一次登录。这对一些`更改密码`或者`进行结账`的访问比较合适。

`Lax`与`Strict`大致相当，表示该`Cookie`仅用作第一方`Cookie`。但去掉了首次从其他网站来的推荐访问不发送`Cookie`的限制。

`None`则表示该`Cookie`可被跨域发送。

在2020年2月4日发布的新版`Chrome 80`中默认值将为`Lax`，而之前的版本默认为`None`。

这样，就可以避免上面的情况。
